---
title: 5.动态内存操作
type: docs
---
![bg](../../../soaring-off.jpg)

这部分的东西还是比较少的

### 1. 动态内存是什么？
在C语言中，变量通常有两种存储方式：

1. 静态/栈内存：局部变量存在栈上，函数结束后自动释放
2. 动态/堆内存：程序运行时按需分配，需要手动释放
3. 动态内存就是程序运行时动态向操作系统申请的一块内存，它的生命周期由程序员控制，而不是由作用域决定

##### 我们为什么要用动态内存 ?
```c
// 静态数组的局限性
int arr[100]; // 大小固定，无法调整
// 编译期就必须确定大小，无法响应运行时需求

// 动态数组的优势
int size = get_user_input(); // 运行时确定大小
int *arr = malloc(size * sizeof(int)); // 按需分配
```

在C语言中使用动态内存需要引入
```c
#include <stdlib.h>
```

动态内存使用的格式是
```text
type *p = (type *)malloc(DataLength);
```
malloc出来的内存是返回void*，表示"无类型指针"，我们需要把它转化成我们需要存储的数据类型

### 2. malloc 和 free
```c
int *p = (int *)malloc(sizeof(int) * 10); // 分配10个int大小的空间
if (p == NULL) {
    // 处理内存分配失败
    // 这里面我们可以写一些提醒，让使用的人知道为什么这里错了
    // 比如我们需要写
    free(p);
    // 因为虽然它失败了，但是这个指针是存在的，我们依旧需要释放掉做这个指针
    return 1; // 自己可以根据代码上下文来写返回值
}
```
> free：释放之前malloc分配的内存

#### 2.1为什么要释放内存
当程序运行时，动态内存是在堆上分配的，这块内存是有限的。如果程序分配了内存但没有释放，就会出现内存泄漏，长期运行可能导致：

1. 程序占用越来越多内存
    - 每次 malloc 都占用堆的一块空间，如果不 free，这些内存无法再被重复利用
2. 系统资源耗尽
    - 对于长期运行的程序（比如服务器），未释放内存会导致操作系统的可用内存越来越少，最终可能导致系统崩溃
3. 程序不稳定
    - 内存泄漏可能引发异常、程序崩溃，或者降低性能(因为系统需要更多时间管理碎片内存)
4. 悬空指针风险
    - 错误释放或重复释放会导致悬空指针，访问这块内存会产生不可预知的错误。
---

```c
free(p);
p = NULL; // 防止悬空指针
```

- 返回值是 void*，可以强制转换成任意类型指针
- 分配失败返回 NULL
- 使用malloc分配的内存未初始化，可能包含垃圾值

### 3. 常见用法
1. 数组动态分配：
```c
int n;
scanf("%d", &n);
int *arr = (int *)malloc(sizeof(int) * n);
```
2. 二维数组动态分配：
```c
int **matrix = (int **)malloc(rows * sizeof(int *));
for (int i = 0; i < rows; i++)
    matrix[i] = (int *)malloc(cols * sizeof(int));
```

3. realloc：调整已分配内存大小
```c
int *temp = (int *)realloc(p, new_size * sizeof(int));
if (temp == NULL) {
    // 处理分配失败，原指针p仍然有效
    free(p);
    return NULL;
}
p = temp; // 只在成功时更新指针
```

### 4. 注意事项
1. 一定要free，否则会内存泄漏
2. 不要重复free，释放后最好置NULL
3. 不要访问未初始化或已释放的内存，会产生悬空指针
4. sizeof类型 vs sizeof指针：分配数组时注意单位

```c
int *arr = malloc(10 * sizeof(int)); // 正确
int *arr = malloc(10 * sizeof(int*)); // 错误
```

---
malloc有很多的变体，`malloc`,`realloc`,`calloc`,`alloca`  
虽然有这么多的变体但是释放内存都是使用`free`

```c
// calloc - 分配并清零内存
int *p = (int *)calloc(10, sizeof(int)); // 自动初始化为0

// alloca 并不是标准C里面的东西，编译器可能会实现，也可能不会实现
// 这个是在栈上进行内存分配，其它的是在堆上进行分配，对于栈和堆我们后面再描述
// 这个东西我推荐各位不要用，很难收场，自己想了解可以搜一下
```

有一个小技巧的东西
```c
// 在调试时有用的一些实践
#define SAFE_FREE(p) do { free(p); (p) = NULL; } while(0)
```
这样我们可以直接做好释放和检测，在写代码的时候不会忘记检测指针是不是残留
